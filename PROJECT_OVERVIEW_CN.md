# Nanobot 项目总览（中文）

本文档用于快速恢复对项目全局的理解，覆盖：架构分层、运行流程、配置权限、工具体系、任务调度、常见故障与排查。
更新时间：2026-02-13
文档索引入口：`docs/文档导航.md`

## 1. 项目定位

Nanobot 是一个以 `Agent Loop` 为核心的自动化助手网关，当前主要通过 Telegram 交互，支持：
- 自然语言对话
- 工具调用（文件、命令、浏览器、邮件、天气、地图、任务等）
- 定时任务执行
- 会话与记忆管理

核心目标：让模型在“可控权限 + 可观测日志 + 可恢复错误”的条件下稳定执行任务。

## 2. 目录结构（按职责）

- `nanobot/`：核心运行代码
- `workspace/`：工作区内容（用户规则、技能、脚本、文档）
- `.home/`：运行时数据（配置、会话、日志、任务存储）
- `docs/`：补充说明文档
- `start.sh`：启动入口脚本

关键子目录：
- `nanobot/agent/`：Agent 主循环、执行器、工具注册、上下文构建
- `nanobot/agent/tools/`：各工具实现
- `nanobot/channels/`：Telegram 等消息通道
- `nanobot/config/`：配置加载与 schema
- `nanobot/cron/`：定时任务服务
- `workspace/skills/`：技能定义
- `workspace/scripts/`：可执行脚本
- `.home/sessions/`：会话文件
- `.home/gateway.log`：运行日志

## 3. 运行主流程

### 3.1 启动链路

1. 读取配置（主要来自 `.home/config.json`）
2. 初始化 provider registry（模型后端）
3. 初始化 Agent Loop + Tool Registry
4. 初始化消息通道（Telegram）
5. 启动 cron 服务（如启用）
6. 开始长轮询收消息

### 3.2 单条消息处理链

1. 通道收到用户消息，封装为内部消息对象
2. Agent Loop 组装上下文（系统提示、用户输入、历史摘要等）
3. 调用模型生成下一步
4. 若模型要求调用工具：进入 ToolExecutor
5. 工具结果回写上下文，再次调用模型
6. 满足结束条件后，输出最终文本到用户

## 4. 工具调用机制

### 4.1 工具注册

工具在 `nanobot/agent/tool_bootstrapper.py` 统一注册，受配置开关控制（`enabled_tools/disabled_tools`）。

### 4.2 执行与防护

- 执行器：`nanobot/agent/executor.py`
- 统一结果协议：`ToolResult`
- 失败处理：异常捕获 + 结构化错误返回
- 循环防护：检测重复调用并中断/纠偏
- 预算控制：限制单轮工具调用总量，防止无限试探
- 事实校验：`turn_engine` 记录真实执行统计，`user_turn_service` 在回包前做“完成话术”真值纠偏

### 4.3 故障中枢（Incident Manager）

- 位置：`nanobot/agent/incident_manager.py`
- 输入：`FailureEvent`（来源、分类、级别、可重试标记、指纹）
- 行为：故障去重、窗口计数、升级判定、持久化到 `runtime/failures.json`
- 通知策略：默认“可自愈不打扰”，仅升级级别故障提示用户

### 4.4 现在的设计原则

- 模型“声明意图”
- 本地代码“真正执行”
- 结果“结构化返回”

说明：即使底层接入 MCP，模型侧通常仍通过本地工具接口调用，不直接裸连外部 MCP 协议细节。

## 5. 配置与权限模型

### 5.1 配置来源

- 主配置：`.home/config.json`
- 各工具配置：`.home/tool_configs/*_config.json`（按工具）

### 5.2 关键权限开关

- `tools.restrict_to_workspace`：是否限制工具只访问工作区
- `tools.exec.mode`：命令执行模式（当前常见为 `host`）
- `tools.file_write_policy`：文件写策略（只读/受控写）

### 5.3 文件写策略语义

- `read_only_patterns`：命中后禁止写
- `controlled_patterns`：命中后需确认（视配置）
- 未命中规则的路径：按默认策略可写

注意：`nanobot/config/*.py` 只读规则仅作用于该目录，不是所有 `.py`。

## 6. 会话、记忆与任务

### 6.1 会话

- 会话存储在 `.home/sessions/`
- 每个会话文件记录历史上下文
- 删除会话文件可实现“清空对话记忆”

补充：可通过 `system_status` 的 `reset_runtime` 动作执行运行态清理（需显式确认）。

### 6.2 任务

- 任务定义存储于 `.home/tasks.json`
- 定时执行由 `cron` 服务触发
- 任务脚本建议放在 `workspace/scripts/`，便于管理和迭代

### 6.3 记忆边界

- 对话历史用于短期连续性
- 持久配置/偏好应写入配置或规则文档，不要只依赖临时会话

## 7. 日志与可观测性

重点日志文件：`.home/gateway.log`

建议重点关注：
- provider 注册失败
- Telegram polling 冲突（常见为重复实例）
- 工具超时、预算超限、重复调用拦截
- 任务执行开始/结束与异常栈

常用排查思路：
1. 先看是否有重复进程
2. 再看模型后端连通性
3. 再看工具配置/Key 是否正确
4. 最后看是否命中策略限制（只读/受控写/预算）

## 8. 常见问题（结合当前项目）

### 8.1 Telegram `Conflict: terminated by other getUpdates request`

原因：同一 bot token 有多个进程同时长轮询。
处理：保留一个网关实例，清理重复进程后重启。

### 8.2 工具调用很多步但无最终回复

原因常见为：
- 循环防护触发
- 工具预算超限
- 模型只产出“动作”未产出最终文本

处理：保留强制总结兜底、适当上调预算、优化工具选择规则。

### 8.3 定时任务时间异常（时区偏移）

原因：任务创建时区与系统默认时区不一致。
处理：统一在任务创建/执行链路中显式指定时区。

## 9. 当前架构的优点与风险

### 9.1 优点

- 工具执行路径清晰，可控性强
- 权限规则可配置，便于逐步收紧
- 日志比较集中，排查效率高

### 9.2 风险点

- `exec(host)` 权限较高，需配合白名单/禁令
- 工具增多后，路由策略容易混乱
- 规则文档与代码策略可能重复，维护成本升高

## 10. 建议的维护节奏

### 每周

- 清理无用会话与历史日志
- 检查任务失败率和超时任务
- 复核新增工具是否补齐配置文档

### 每次改动后

- 跑一次启动自检
- 验证 3 类关键路径：普通问答、工具调用、定时任务
- 更新对应文档（至少 README/TOOLS/配置说明之一）

### 每次发布前

- 确认只读/受控写策略仍符合预期
- 确认仅有一个 Telegram polling 实例
- 确认默认模型与备用模型可用

## 11. 一句话总结

当前项目已经具备“可用、可扩展、可排障”的基础能力；后续重点是继续把“高权限工具约束 + 工具路由收敛 + 文档与代码一致性”三件事做稳。
